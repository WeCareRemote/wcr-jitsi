name: Deploy Jitsi Stack
run-name: >
  ${{ github.event_name == 'workflow_dispatch' 
      && format('Build and Deploy Jitsi Stack to {0} environment > {1}', github.event.inputs.environment, github.event.inputs.cloud) 
      || format('Build and Deploy Jitsi Stack to {0} environment', github.ref_name == 'master' && 'production' || 'development') }}

on:
  workflow_dispatch:
    inputs:
      environment:
        type: environment
        description: Type environment
        required: true
        default: development
      backend_tag:
        type: string
        description: Type backend tag
        required: true
        default: latest
      cloud:
        type: choice
        description: Type cloud
        required: true
        options:
          - aws
          - azure
      build_only:
        type: boolean
        description: Type build only
        required: true
        default: false

env:
  APP_PATH: /opt/greyt
  STACK_PATH: /opt/greyt/jibri-stack
  ECR_URL: "${{ secrets.ACCOUNT_ID }}.dkr.ecr.eu-central-1.amazonaws.com"
  ACR_URL: "${{ secrets.AZURE_ACR_NAME }}.azurecr.io"
  CONTAINER_REGISTRY: "ecr-jitsi"
  SERVICE_NAME: jitsi_records_backend
  APPLICATION: "jitsi_records_backend"
  DOCKERFILE_PATH: "jitsi_records_backend/docker/Dockerfile"
  BUILD_CONTEXT: "jitsi_records_backend"
  SSH_IP: "${{ github.event.inputs.cloud == 'aws' && secrets.AWS_SSH_IP || github.event.inputs.cloud == 'azure' && secrets.AZURE_SSH_IP }}"
  SSH_KEY: "${{ github.event.inputs.cloud == 'aws' && secrets.AWS_SSH_KEY || github.event.inputs.cloud == 'azure' && secrets.AZURE_SSH_KEY }}"
  SSH_USER: "${{ github.event.inputs.cloud == 'aws' && secrets.AWS_SSH_USER || github.event.inputs.cloud == 'azure' && secrets.AZURE_SSH_USER }}"
  DB_HOST: "${{ (github.event.inputs.cloud == 'aws' && secrets.AWS_DB_HOST) || (github.event.inputs.cloud == 'azure' && secrets.AZURE_DB_HOST)  }}"
  DB_PASSWORD: "${{ (github.event.inputs.cloud == 'aws' && secrets.AWS_DB_PASSWORD) || (github.event.inputs.cloud == 'azure' && secrets.AZURE_DB_PASSWORD) }}"
  DB_USERNAME: "${{ (github.event.inputs.cloud == 'aws' && secrets.AWS_DB_USERNAME) || (github.event.inputs.cloud == 'azure' && secrets.AZURE_DB_USERNAME) }}"

jobs:
  build:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'development'}}
    steps:
      - uses: actions/checkout@v4
      - name: AWS login
        if: github.event.inputs.cloud == 'aws'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.SECRET_KEY }}
          aws-region: eu-central-1
      - name: ECR login
        if: github.event.inputs.cloud == 'aws'
        run: |
          aws ecr get-login-password --region eu-central-1 | docker login --username AWS --password-stdin ${{ env.ECR_URL }}
      - name: ACR login
        if: github.event.inputs.cloud == 'azure'
        run: |
          az login --service-principal --username ${{ secrets.AZURE_SP_APP_ID }} --password ${{ secrets.AZURE_SP_PASSWORD }} --tenant ${{ secrets.AZURE_TENANT_ID }}
          az acr login --name ${{ secrets.AZURE_ACR_NAME }}
      - name: Build and push Docker image
        run: |
          docker build -f ${{ env.DOCKERFILE_PATH }} \
          -t ${{ env.APPLICATION }}:${{ github.event.inputs.backend_tag || 'latest'}} ${{ env.BUILD_CONTEXT }} \
          --build-arg AWS_ACCESS_KEY_ID='${{ secrets.AWS_ACCESS_KEY_ID }}' \
          --build-arg AWS_SECRET_ACCESS_KEY='${{ secrets.AWS_SECRET_ACCESS_KEY }}' \
          --build-arg DB_HOST='${{ env.DB_HOST }}' \
          --build-arg DB_DATABASE='${{ secrets.DB_DATABASE }}' \
          --build-arg DB_PASSWORD='${{ env.DB_PASSWORD }}' \
          --build-arg DB_USERNAME='${{ env.DB_USERNAME }}' \
          --build-arg DB_PORT='${{ secrets.DB_PORT }}' \
          --build-arg STORAGE_HOST='${{ secrets.STORAGE_HOST }}' \
          --build-arg GREYT_HOST='${{ secrets.GREYT_HOST }}' \
          --build-arg APP_MODULE='${{ secrets.APP_MODULE }}' \
          --build-arg RECORDS_DIR='${{ secrets.RECORDS_DIR }}' \
          --build-arg APP_MODE='${{ secrets.APP_MODE }}' \
          --build-arg RECORDS_HANDLER_TOKEN='${{ secrets.RECORDS_HANDLER_TOKEN }}' \
          --build-arg S3_BUCKET='${{ secrets.S3_BUCKET }}'
          docker tag ${{ env.APPLICATION }}:${{ github.event.inputs.backend_tag || 'latest'}} ${{ (github.event.inputs.cloud == 'azure' && env.ACR_URL) || (github.event.inputs.cloud == 'aws' && env.ECR_URL) }}/${{ env.CONTAINER_REGISTRY }}:${{ github.event.inputs.backend_tag || 'latest'}}
          docker push ${{ (github.event.inputs.cloud == 'azure' && env.ACR_URL) || (github.event.inputs.cloud == 'aws' && env.ECR_URL) }}/${{ env.CONTAINER_REGISTRY }}:${{ github.event.inputs.backend_tag || 'latest'}}
      - name: AWS login
        if: github.event.inputs.cloud == 'aws'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.SECRET_KEY }}
          aws-region: eu-central-1
      - name: EKS login
        if: github.event.inputs.cloud == 'aws'
        run: |
          aws ecr get-login-password --region eu-central-1 | docker login --username AWS --password-stdin ${{ env.ECR_URL }}
      - name: ACS login
        if: github.event.inputs.cloud == 'azure'
        run: |
          az login --service-principal --username ${{ secrets.AZURE_SP_APP_ID }} --password ${{ secrets.AZURE_SP_PASSWORD }} --tenant ${{ secrets.AZURE_TENANT_ID }}
          az acr login --name ${{ env.ACR_URL }}

  deploy:
    if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.build_only != 'true' }}
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'development'}}
    needs: [build]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install rsync and ssh
        run: |
          sudo apt-get update -y
          sudo apt-get install -y rsync openssh-client

      - name: Set up SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          ssh-keyscan ${{ env.SSH_IP }} >> ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

      - name: Sync Jitsi files to server
        run: |
          eval $(ssh-agent -s)
          echo "${{ env.SSH_KEY }}" | tr -d '\r' | ssh-add -
          rsync -az ./jibri-stack ${{ env.SSH_USER }}@${{ env.SSH_IP }}:${{ env.APP_PATH }}/
          rsync -az ./jitsi_records_backend ${{ env.SSH_USER }}@${{ env.SSH_IP }}:${{ env.APP_PATH }}/

      - name: Restart only Jitsi stack
        run: |
          eval $(ssh-agent -s)
          echo "${{ env.SSH_KEY }}" | tr -d '\r' | ssh-add -
          ssh ${{ env.SSH_USER }}@${{ env.SSH_IP }} <<'EOF'
          set -e
          set -Eeuo pipefail
          set -x
          echo "Logging in to ${{ github.event.inputs.cloud }}"
          cd ${{ env.STACK_PATH }}
          if [ "${{ github.event.inputs.cloud }}" = "aws" ]; then
            aws ecr get-login-password --region eu-central-1 | docker login --username AWS --password-stdin ${{ env.ECR_URL }}
            REGISTRY="${{ env.ECR_URL }}"
          elif [ "${{ github.event.inputs.cloud }}" = "azure" ]; then
            az login --service-principal --username ${{ secrets.AZURE_SP_APP_ID }} --password ${{ secrets.AZURE_SP_PASSWORD }} --tenant ${{ secrets.AZURE_TENANT_ID }}
            az acr login --name ${{ secrets.AZURE_ACR_NAME }}
            REGISTRY="${{ env.ACR_URL }}"
          else
            echo "Invalid cloud"; exit 1
          fi
          docker compose --env-file ../.env --profile ${{ github.event.inputs.environment }} down
          sed -i "s|^JITSI=.*|JITSI=${REGISTRY}/${{ env.CONTAINER_REGISTRY }}:${{ github.event.inputs.backend_tag || 'latest'}}|g" ../.env
          XMPP_DOMAIN='${{ secrets.XMPP_DOMAIN }}' \
          XMPP_AUTH_DOMAIN='${{ secrets.XMPP_AUTH_DOMAIN }}' \
          XMPP_INTERNAL_MUC_DOMAIN='${{ secrets.XMPP_INTERNAL_MUC_DOMAIN }}' \
          XMPP_RECORDER_DOMAIN='${{ secrets.XMPP_RECORDER_DOMAIN }}' \
          XMPP_SERVER='${{ secrets.XMPP_SERVER }}' \
          XMPP_BOSH_URL_BASE='${{ secrets.XMPP_BOSH_URL_BASE }}' \
          XMPP_GUEST_DOMAIN='${{ secrets.XMPP_GUEST_DOMAIN }}' \
          JICOFO_AUTH_USER='${{ secrets.JICOFO_AUTH_USER }}' \
          JICOFO_AUTH_PASSWORD='${{ secrets.JICOFO_AUTH_PASSWORD }}' \
          JICOFO_COMPONENT_SECRET='${{ secrets.JICOFO_COMPONENT_SECRET }}' \
          JVB_AUTH_USER='${{ secrets.JVB_AUTH_USER }}' \
          JVB_AUTH_PASSWORD='${{ secrets.JVB_AUTH_PASSWORD }}' \
          JVB_BREWERY_MUC='${{ secrets.JVB_BREWERY_MUC }}' \
          JIBRI_XMPP_USER='${{ secrets.JIBRI_XMPP_USER }}' \
          JIBRI_XMPP_PASSWORD='${{ secrets.JIBRI_XMPP_PASSWORD }}' \
          JIBRI_BREWERY_MUC='${{ secrets.JIBRI_BREWERY_MUC }}' \
          JIBRI_RECORDER_USER='${{ secrets.JIBRI_RECORDER_USER }}' \
          DOCKER_HOST_ADDRESS='${{ env.SSH_IP }}' \
          JVB_ADVERTISE_IPS='${{ env.SSH_IP }}' \
          COLIBRI_WS_DOMAIN='${{ secrets.COLIBRI_WS_DOMAIN }}' \
          COLIBRI_WS_SERVER_ID='default-id' \
          ENABLE_COLIBRI_WEBSOCKET='1' \
          PUBLIC_URL='${{ secrets.PUBLIC_URL }}' \
          ENABLE_XMPP_WEBSOCKET='1' \
          XMPP_WEBSOCKET_URL='${{ secrets.XMPP_WEBSOCKET_URL }}' \
          JIBRI_RECORDER_PASSWORD='${{ secrets.JIBRI_RECORDER_PASSWORD }}' \
          JIBRI_RECORDING_DIR='${{ secrets.JIBRI_RECORDING_DIR }}' \
          JIBRI_FINALIZE_RECORDING_SCRIPT_PATH='${{ secrets.JIBRI_FINALIZE_RECORDING_SCRIPT_PATH }}' \
          RECORDS_TOKEN='${{ secrets.RECORDS_HANDLER_TOKEN }}' \
          JIBRI_LOGS_DIR='${{ secrets.JIBRI_LOGS_DIR }}' \
          DISPLAY='${{ secrets.DISPLAY }}' \
          TZ='${{ secrets.TZ }}' \
          JITSI="${REGISTRY}/${{ env.CONTAINER_REGISTRY }}:${{ github.event.inputs.backend_tag || 'latest'}}" \
          docker compose --profile ${{ github.event.inputs.environment }} up -d --build
          EOF
